<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Remora Calendar</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2064%2064'%3E%3Cpath%20fill='%2300693E'%20d='M32%208%20C20%208%2012%2016%2012%2028%20C12%2036%2016%2042%2022%2046%20L20%2056%20L32%2050%20L44%2056%20L42%2046%20C48%2042%2052%2036%2052%2028%20C52%2016%2044%208%2032%208%20M32%2012%20C42%2012%2048%2018%2048%2028%20C48%2034%2045%2039%2040%2042%20L38%2044%20L39%2050%20L32%2046%20L25%2050%20L26%2044%20L24%2042%20C19%2039%2016%2034%2016%2028%20C16%2018%2022%2012%2032%2012'%2F%3E%3Cellipse%20fill='%2300693E'%20cx='26'%20cy='26'%20rx='3'%20ry='4'%2F%3E%3Cellipse%20fill='%2300693E'%20cx='38'%20cy='26'%20rx='3'%20ry='4'%2F%3E%3Cpath%20stroke='%2300693E'%20stroke-width='2'%20fill='none'%20d='M24%2032%20Q32%2036%2040%2032'%2F%3E%3C%2Fsvg%3E">
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --dartmouth-green: #00693E;
      --light-green: #E8F5E9;
      --bg-color: #FFFFFF;
      --border-color: #E5E5E5;
    }
    body {
      background-color: var(--bg-color);
    }
    .current-time-indicator {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background-color: #DC2626;
      z-index: 10;
      pointer-events: none;
    }
    .current-time-indicator::before {
      content: '';
      position: absolute;
      left: -6px;
      top: -5px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: #DC2626;
    }
    .event-dragging {
      opacity: 0.5;
      cursor: grabbing;
    }
    @keyframes mergeConsume {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(0.9);
        opacity: 0.7;
      }
      100% {
        transform: scale(0);
        opacity: 0;
      }
    }
    .merging-out {
      animation: mergeConsume 0.5s ease-out forwards;
    }
    @keyframes eventRise {
      0% {
        transform: translateY(0) scale(1);
      }
      100% {
        transform: translateY(-2px) scale(1.02);
      }
    }
    @keyframes eventShake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-1px); }
      75% { transform: translateX(1px); }
    }
    .event-block {
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      transition: all 0.2s;
    }
    .event-block:hover {
      animation: eventRise 0.2s ease-out forwards;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10 !important;
    }
    .event-dragging-active {
      animation: eventShake 0.1s infinite;
      box-shadow: 0 8px 20px rgba(0,0,0,0.25);
      cursor: grabbing !important;
      z-index: 1000 !important;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CalendarApp = () => {
      const [isSignedIn, setIsSignedIn] = useState(false);
      const [calendars, setCalendars] = useState([]);
      const [events, setEvents] = useState([]);
      const [view, setView] = useState('day');
      const [currentDate, setCurrentDate] = useState(new Date());
      const [columns, setColumns] = useState([]);
      const [showSettings, setShowSettings] = useState(false);
      const [defaultCalendar, setDefaultCalendar] = useState('');
      const [showEventModal, setShowEventModal] = useState(false);
      const [selectedEvent, setSelectedEvent] = useState(null);
      const [isDragging, setIsDragging] = useState(false);
      const [dragStart, setDragStart] = useState(null);
      const [dragEnd, setDragEnd] = useState(null);
      const [draggingEvent, setDraggingEvent] = useState(null);
      const [dragOffset, setDragOffset] = useState(null);
      const [dragPosition, setDragPosition] = useState(null);
      const [mergingEvents, setMergingEvents] = useState(null);
      const [showMergeDialog, setShowMergeDialog] = useState(null);
      const [hoveredEvent, setHoveredEvent] = useState(null);
      const [currentTime, setCurrentTime] = useState(new Date());
      const [isLoading, setIsLoading] = useState(false);
      const [loadingMessage, setLoadingMessage] = useState('');
      const [error, setError] = useState(null);
      const [eventCache, setEventCache] = useState({});
      const [showOnlyColumn1, setShowOnlyColumn1] = useState(false);
      const [hiddenEvents, setHiddenEvents] = useState(new Set());
      const [timeZoneOffset, setTimeZoneOffset] = useState(-4.5);
      const [visibleHourStart, setVisibleHourStart] = useState(6);
      const [visibleHourEnd, setVisibleHourEnd] = useState(23);
      const [hiddenCalendars, setHiddenCalendars] = useState(new Set());
      const [editingCalendarColor, setEditingCalendarColor] = useState(null);
      const [calendarColors, setCalendarColors] = useState({});
      const clientId = '788943371871-n713sgr9t3oifkev2abln7615eulgbv4.apps.googleusercontent.com';

      // Helper function to format a Date as a local RFC3339-like string without timezone
      const toLocalDateTimeString = (date) => {
        const pad = (n) => String(n).padStart(2, '0');
        return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())}` +
               `T${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
      };

      // Helper to get grid context for accurate drag/drop calculations
      const getGridContextForPoint = (x, y) => {
        const calendarColumns = document.querySelectorAll('.calendar-column');
        let targetColumn = null;
        
        calendarColumns.forEach((col) => {
          const rect = col.getBoundingClientRect();
          if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
            targetColumn = col;
          }
        });
        
        if (!targetColumn) return null;
        
        // Prefer the scrollable time-grid element if it exists
        const timeGrid = targetColumn.querySelector('.time-grid');
        const gridElement = timeGrid || targetColumn;
        const gridRect = gridElement.getBoundingClientRect();
        const scrollTop = gridElement.scrollTop || 0;
        
        // Measure hourHeight from first hour slot if available
        const firstHourSlot = targetColumn.querySelector('[data-hour-slot]');
        const hourHeight = firstHourSlot ? firstHourSlot.getBoundingClientRect().height : 64;
        
        return {
          targetColumn,
          gridRect,
          scrollTop,
          hourHeight
        };
      };

      // Update current time every minute
      useEffect(() => {
        const interval = setInterval(() => {
          setCurrentTime(new Date());
        }, 60000);
        return () => clearInterval(interval);
      }, []);

      // Keyboard shortcuts
      useEffect(() => {
        const handleKeyPress = (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
          if (e.key === 'd') setView('day');
          if (e.key === 'w') setView('week');
          if (e.key === 'm') setView('month');
        };
        window.addEventListener('keydown', handleKeyPress);
        return () => window.removeEventListener('keydown', handleKeyPress);
      }, []);

      // Global mouse up handler for drag end
      useEffect(() => {
        const handleGlobalMouseUp = (e) => {
          if (draggingEvent) {
            handleEventDragEnd(e, null);
          }
        };
        
        const handleGlobalMouseMove = (e) => {
          if (draggingEvent && dragOffset) {
            setDragPosition({ x: e.clientX, y: e.clientY });
          }
        };
        
        window.addEventListener('mouseup', handleGlobalMouseUp);
        window.addEventListener('mousemove', handleGlobalMouseMove);
        return () => {
          window.removeEventListener('mouseup', handleGlobalMouseUp);
          window.removeEventListener('mousemove', handleGlobalMouseMove);
        };
      }, [draggingEvent, dragOffset]);

      useEffect(() => {
        const hash = window.location.hash;
        if (hash) {
          const params = new URLSearchParams(hash.substring(1));
          const accessToken = params.get('access_token');
          if (accessToken) {
            localStorage.setItem('google_access_token', accessToken);
            window.location.hash = '';
            loadCalendarsAndEvents(accessToken);
          }
        } else {
          const token = localStorage.getItem('google_access_token');
          if (token) {
            // Test if token is still valid
            testTokenAndLoad(token);
          }
        }

        // Load default calendar and show only column 1 setting
        const savedDefault = localStorage.getItem('default_calendar');
        if (savedDefault) {
          setDefaultCalendar(savedDefault);
        }
        
        const savedShowOnlyColumn1 = localStorage.getItem('show_only_column1');
        if (savedShowOnlyColumn1 !== null) {
          setShowOnlyColumn1(savedShowOnlyColumn1 === 'true');
        }
        
        const savedTimeZoneOffset = localStorage.getItem('timezone_offset');
        if (savedTimeZoneOffset !== null) {
          setTimeZoneOffset(parseFloat(savedTimeZoneOffset));
        }
        
        const savedVisibleHourStart = localStorage.getItem('visible_hour_start');
        if (savedVisibleHourStart !== null) {
          setVisibleHourStart(parseInt(savedVisibleHourStart));
        }
        
        const savedVisibleHourEnd = localStorage.getItem('visible_hour_end');
        if (savedVisibleHourEnd !== null) {
          setVisibleHourEnd(parseInt(savedVisibleHourEnd));
        }
        
        const savedHiddenCalendars = localStorage.getItem('hidden_calendars');
        if (savedHiddenCalendars) {
          setHiddenCalendars(new Set(JSON.parse(savedHiddenCalendars)));
        }
        
        const savedCalendarColors = localStorage.getItem('calendar_colors');
        if (savedCalendarColors) {
          setCalendarColors(JSON.parse(savedCalendarColors));
        }
      }, []);

      const testTokenAndLoad = async (token) => {
        try {
          setIsLoading(true);
          setLoadingMessage('Checking credentials...');
          const response = await fetch('https://www.googleapis.com/calendar/v3/users/me/calendarList', {
            headers: { Authorization: `Bearer ${token}` }
          });
          
          if (response.ok) {
            loadCalendarsAndEvents(token);
          } else {
            // Token expired, need to re-authenticate
            localStorage.removeItem('google_access_token');
            setIsLoading(false);
            setError('Session expired. Please sign in again.');
          }
        } catch (error) {
          console.error('Error testing token:', error);
          setIsLoading(false);
          setError('Failed to connect. Please sign in again.');
        }
      };

      const loadCalendarsAndEvents = async (accessToken) => {
        setIsLoading(true);
        setError(null);
        try {
          await loadCalendars(accessToken);
          setIsSignedIn(true);
        } catch (error) {
          console.error('Error loading data:', error);
          setError('Failed to load calendar data. Please try refreshing.');
          setIsLoading(false);
        }
      };

      const signIn = () => {
        let redirectUri = window.location.href.split('#')[0].split('?')[0];
        if (!redirectUri.endsWith('/')) {
          redirectUri += '/';
        }
        const scope = 'https://www.googleapis.com/auth/calendar';
        const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=token&scope=${encodeURIComponent(scope)}&prompt=consent`;
        window.location.href = authUrl;
      };

      const signOut = () => {
        localStorage.removeItem('google_access_token');
        setIsSignedIn(false);
        setCalendars([]);
        setEvents([]);
      };

      const loadCalendars = async (accessToken) => {
        try {
          setLoadingMessage('Loading calendars...');
          const response = await fetch('https://www.googleapis.com/calendar/v3/users/me/calendarList', {
            headers: { Authorization: `Bearer ${accessToken}` }
          });
          
          if (!response.ok) {
            throw new Error(`Failed to load calendars: ${response.status}`);
          }
          
          const data = await response.json();
          setCalendars(data.items || []);
          
          // Store colors locally on first load (desync from Google)
          const savedColors = localStorage.getItem('calendar_colors');
          if (!savedColors && data.items) {
            const initialColors = {};
            data.items.forEach(cal => {
              initialColors[cal.id] = cal.backgroundColor;
            });
            setCalendarColors(initialColors);
            localStorage.setItem('calendar_colors', JSON.stringify(initialColors));
          }
          
          const savedColumns = localStorage.getItem('calendar_columns');
          if (savedColumns) {
            setColumns(JSON.parse(savedColumns));
          } else {
            setColumns([{ id: '1', name: 'Column 1', calendarIds: data.items?.map(cal => cal.id) || [] }]);
          }
          
          const savedDefault = localStorage.getItem('default_calendar');
          if (savedDefault) {
            setDefaultCalendar(savedDefault);
          } else if (data.items && data.items.length > 0) {
            setDefaultCalendar(data.items[0].id);
          }
          
          // Now load events
          await loadEventsForCalendars(accessToken, data.items || []);
          setIsLoading(false);
        } catch (error) {
          console.error('Error loading calendars:', error);
          setIsLoading(false);
          if (error.message?.includes('401')) {
            localStorage.removeItem('google_access_token');
            setError('Session expired. Please sign in again.');
            setIsSignedIn(false);
          } else {
            setError('Failed to load calendars. Please refresh the page.');
          }
        }
      };

      const loadEventsForCalendars = async (accessToken, calendarList) => {
        try {
          setLoadingMessage('Loading events...');
          const token = accessToken || localStorage.getItem('google_access_token');
          
          const now = new Date();
          const currentMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
          const currentMonthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);
          const futureMonthEnd = new Date(now.getFullYear(), now.getMonth() + 2, 0, 23, 59, 59);
          const pastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);

          const allEvents = [];
          
          // Priority 1: Current month
          setLoadingMessage('Loading current month...');
          const currentMonthEvents = await loadEventsForTimeRange(token, calendarList, currentMonthStart, currentMonthEnd);
          allEvents.push(...currentMonthEvents);
          setEvents([...allEvents]);
          
          // Priority 2: Next month
          setLoadingMessage('Loading future events...');
          const futureEvents = await loadEventsForTimeRange(token, calendarList, currentMonthEnd, futureMonthEnd);
          allEvents.push(...futureEvents);
          setEvents([...allEvents]);
          
          // Priority 3: Previous month
          setLoadingMessage('Loading past events...');
          const pastEvents = await loadEventsForTimeRange(token, calendarList, pastMonthStart, currentMonthStart);
          allEvents.push(...pastEvents);
          setEvents([...allEvents]);
          
          setLoadingMessage('');
        } catch (error) {
          console.error('Error loading events:', error);
          setError('Some events failed to load.');
          setLoadingMessage('');
        }
      };

      const loadEventsForTimeRange = async (token, calendarList, timeMin, timeMax) => {
        const cacheKey = `${timeMin.toISOString()}-${timeMax.toISOString()}`;
        
        // Check cache first
        if (eventCache[cacheKey]) {
          return eventCache[cacheKey];
        }

        const allEvents = [];
        const eventPromises = calendarList.map(async (calendar) => {
          try {
            const response = await fetch(
              `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendar.id)}/events?timeMin=${timeMin.toISOString()}&timeMax=${timeMax.toISOString()}&singleEvents=true&maxResults=2500`,
              { headers: { Authorization: `Bearer ${token}` } }
            );
            
            if (!response.ok) {
              console.warn(`Failed to load events for ${calendar.summary}`);
              return [];
            }
            
            const data = await response.json();
            return (data.items || []).map(event => ({ 
              ...event, 
              calendarId: calendar.id, 
              calendarColor: calendar.backgroundColor 
            }));
          } catch (error) {
            console.warn(`Error loading events for ${calendar.summary}:`, error);
            return [];
          }
        });
        
        const eventArrays = await Promise.all(eventPromises);
        eventArrays.forEach(events => allEvents.push(...events));
        
        // Cache the results
        setEventCache(prev => ({...prev, [cacheKey]: allEvents}));
        
        return allEvents;
      };

      const loadEvents = async (accessToken) => {
        if (calendars.length === 0) return;
        
        // Check if we need to load more data
        const now = new Date();
        const viewStart = new Date(currentDate);
        viewStart.setDate(1);
        const viewEnd = new Date(currentDate);
        viewEnd.setMonth(viewEnd.getMonth() + 1);
        
        // Only reload if viewing a time period we don't have cached
        const needsReload = !Object.keys(eventCache).some(key => {
          const [start, end] = key.split('-');
          const cacheStart = new Date(start);
          const cacheEnd = new Date(end);
          return viewStart >= cacheStart && viewEnd <= cacheEnd;
        });
        
        if (!needsReload) {
          // Use cached data
          const relevantEvents = Object.values(eventCache)
            .flat()
            .filter(event => {
              const eventDate = new Date(event.start.dateTime || event.start.date);
              return eventDate >= viewStart && eventDate <= viewEnd;
            });
          setEvents(relevantEvents);
          return;
        }
        
        try {
          setLoadingMessage('Refreshing events...');
          await loadEventsForCalendars(accessToken, calendars);
          setLoadingMessage('');
        } catch (error) {
          console.error('Error loading events:', error);
          setLoadingMessage('');
        }
      };

      useEffect(() => {
        if (calendars.length > 0 && isSignedIn) {
          loadEvents();
        }
      }, [currentDate, calendars]);

      const createEvent = async (eventData) => {
        try {
          const token = localStorage.getItem('google_access_token');
          const calendarId = eventData.calendarId || defaultCalendar;
          
          // Get the calendar's timeZone, fallback to browser's timezone
          const calendar = calendars.find(cal => cal.id === calendarId);
          const timeZone = calendar?.timeZone || Intl.DateTimeFormat().resolvedOptions().timeZone;
          
          // Convert to local datetime strings (no timezone conversion needed)
          const startTime = new Date(eventData.start);
          const endTime = new Date(eventData.end);
          
          const response = await fetch(
            `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,
            {
              method: 'POST',
              headers: {
                Authorization: `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                summary: eventData.title,
                description: eventData.description,
                start: { 
                  dateTime: toLocalDateTimeString(startTime),
                  timeZone: timeZone
                },
                end: { 
                  dateTime: toLocalDateTimeString(endTime),
                  timeZone: timeZone
                }
              })
            }
          );
          
          if (response.ok) {
            await loadEvents();
            setShowEventModal(false);
            setSelectedEvent(null);
          }
        } catch (error) {
          console.error('Error creating event:', error);
        }
      };

      const updateEvent = async (eventData) => {
        try {
          const token = localStorage.getItem('google_access_token');
          
          // Get the calendar's timeZone, fallback to browser's timezone
          const calendar = calendars.find(cal => cal.id === eventData.calendarId);
          const timeZone = calendar?.timeZone || Intl.DateTimeFormat().resolvedOptions().timeZone;
          
          // Convert to local datetime strings (no timezone conversion needed)
          const startTime = new Date(eventData.start);
          const endTime = new Date(eventData.end);
          
          const response = await fetch(
            `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(eventData.calendarId)}/events/${eventData.id}`,
            {
              method: 'PUT',
              headers: {
                Authorization: `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                summary: eventData.title,
                description: eventData.description,
                start: { 
                  dateTime: toLocalDateTimeString(startTime),
                  timeZone: timeZone
                },
                end: { 
                  dateTime: toLocalDateTimeString(endTime),
                  timeZone: timeZone
                }
              })
            }
          );
          
          if (response.ok) {
            await loadEvents();
            setShowEventModal(false);
            setSelectedEvent(null);
          }
        } catch (error) {
          console.error('Error updating event:', error);
        }
      };

      const deleteEvent = async (event) => {
        try {
          const token = localStorage.getItem('google_access_token');
          
          await fetch(
            `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(event.calendarId)}/events/${event.id}`,
            {
              method: 'DELETE',
              headers: { Authorization: `Bearer ${token}` }
            }
          );
          
          await loadEvents();
          setShowEventModal(false);
          setSelectedEvent(null);
        } catch (error) {
          console.error('Error deleting event:', error);
        }
      };

      const addColumn = () => {
        const newColumn = {
          id: Date.now().toString(),
          name: `Column ${columns.length + 1}`,
          calendarIds: []
        };
        const updated = [...columns, newColumn];
        setColumns(updated);
        localStorage.setItem('calendar_columns', JSON.stringify(updated));
      };

      const moveCalendarToColumn = (calendarId, targetColumnId) => {
        const updated = columns.map(col => ({
          ...col,
          calendarIds: col.id === targetColumnId 
            ? [...col.calendarIds.filter(id => id !== calendarId), calendarId]
            : col.calendarIds.filter(id => id !== calendarId)
        }));
        setColumns(updated);
        localStorage.setItem('calendar_columns', JSON.stringify(updated));
      };

      const removeColumn = (columnId) => {
        if (columns.length === 1) return;
        const updated = columns.filter(col => col.id !== columnId);
        setColumns(updated);
        localStorage.setItem('calendar_columns', JSON.stringify(updated));
      };

      const handleMouseDown = (e, hour, columnId) => {
        if (e.target.closest('.event-block')) return;
        const rect = e.currentTarget.getBoundingClientRect();
        const relativeY = e.clientY - rect.top;
        const totalMinutes = (relativeY / rect.height) * 60;
        const snappedMinutes = Math.round(totalMinutes / 15) * 15;
        
        const start = new Date(currentDate);
        start.setHours(hour, snappedMinutes, 0, 0);
        
        setIsDragging(true);
        setDragStart({ time: start, columnId });
        setDragEnd({ time: start, columnId });
      };

      const handleEventDragStart = (e, event) => {
        e.stopPropagation();
        const rect = e.currentTarget.getBoundingClientRect();
        setDraggingEvent(event);
        setDragOffset({
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        });
      };

      const handleEventDrag = (e, hour) => {
        if (!draggingEvent) return;
        // Just visual feedback, actual update happens on mouseup
      };

      const handleEventDragEnd = async (e) => {
        if (!draggingEvent || !dragPosition) return;
      
        const gridContext = getGridContextForPoint(dragPosition.x, dragPosition.y);
        if (!gridContext) {
          setDraggingEvent(null);
          setDragOffset(null);
          setDragPosition(null);
          return;
        }
        
        const { targetColumn, gridRect, scrollTop, hourHeight } = gridContext;
      
        // Calculate drop time using grid context
        const relativeY = dragPosition.y - gridRect.top + scrollTop;
        const hourIndex = Math.floor(relativeY / hourHeight);
        const minuteInHour = ((relativeY % hourHeight) / hourHeight) * 60;
        const snappedMinutes = Math.round(minuteInHour / 15) * 15;
      
        const hour = hourIndex + visibleHourStart;
        const newStart = new Date(currentDate);
        newStart.setHours(hour, snappedMinutes, 0, 0);
        
        const duration =
          new Date(draggingEvent.end.dateTime) -
          new Date(draggingEvent.start.dateTime);
        const newEnd = new Date(newStart.getTime() + duration);
      
        // Determine which calendar this column belongs to
        const columnId = targetColumn.getAttribute('data-column-id');
        const column = columns.find(c => c.id === columnId);
        const targetCalendarId =
          column?.calendarIds[0] || draggingEvent.calendarId;
      
        // Save to Google Calendar
        try {
          const token = localStorage.getItem('google_access_token');
          
          // Get the target calendar's timeZone
          const targetCalendar = calendars.find(cal => cal.id === targetCalendarId);
          const timeZone = targetCalendar?.timeZone || Intl.DateTimeFormat().resolvedOptions().timeZone;
      
          if (targetCalendarId !== draggingEvent.calendarId) {
            // Cross-calendar move: copy first, then delete only if copy succeeds
            const createResponse = await fetch(
              `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(
                targetCalendarId
              )}/events`,
              {
                method: 'POST',
                headers: {
                  Authorization: `Bearer ${token}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  summary: draggingEvent.summary,
                  description: draggingEvent.description,
                  start: { 
                    dateTime: toLocalDateTimeString(newStart),
                    timeZone: timeZone
                  },
                  end: { 
                    dateTime: toLocalDateTimeString(newEnd),
                    timeZone: timeZone
                  }
                })
              }
            );
            
            if (!createResponse.ok) {
              console.error('Failed to create event on target calendar');
              setDraggingEvent(null);
              setDragOffset(null);
              setDragPosition(null);
              return;
            }
            
            // Only delete original event if creation succeeded
            await fetch(
              `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(
                draggingEvent.calendarId
              )}/events/${draggingEvent.id}`,
              {
                method: 'DELETE',
                headers: { Authorization: `Bearer ${token}` }
              }
            );
          } else {
            // Within-calendar move: use PUT to update
            await fetch(
              `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(
                draggingEvent.calendarId
              )}/events/${draggingEvent.id}`,
              {
                method: 'PUT',
                headers: {
                  Authorization: `Bearer ${token}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  summary: draggingEvent.summary,
                  description: draggingEvent.description,
                  start: { 
                    dateTime: toLocalDateTimeString(newStart),
                    timeZone: timeZone
                  },
                  end: { 
                    dateTime: toLocalDateTimeString(newEnd),
                    timeZone: timeZone
                  }
                })
              }
            );
          }
      
          setEventCache({});
          await loadEvents();
        } catch (error) {
          console.error('Error moving event:', error);
        }
      
        setDraggingEvent(null);
        setDragOffset(null);
        setDragPosition(null);
      };
      
      const handleMouseMove = (e, hour) => {
        if (isDragging && !draggingEvent) {
          const rect = e.currentTarget.getBoundingClientRect();
          const relativeY = e.clientY - rect.top;
          const totalMinutes = (relativeY / rect.height) * 60;
          const snappedMinutes = Math.round(totalMinutes / 15) * 15;
          
          const end = new Date(currentDate);
          end.setHours(hour, snappedMinutes, 0, 0);
          setDragEnd({ time: end, columnId: dragStart.columnId });
        }
        
        if (draggingEvent && dragOffset) {
          setDragPosition({ x: e.clientX, y: e.clientY });
        }
      };

      const getDropPreviewPosition = () => {
        if (!draggingEvent || !dragPosition) return null;
        
        const gridContext = getGridContextForPoint(dragPosition.x, dragPosition.y);
        if (!gridContext) return null;
        
        const { targetColumn, gridRect, scrollTop, hourHeight } = gridContext;
        
        // Calculate relative position within the scrollable grid
        const relativeY = dragPosition.y - gridRect.top + scrollTop;
        const hourIndex = Math.floor(relativeY / hourHeight);
        const minuteInHour = ((relativeY % hourHeight) / hourHeight) * 60;
        const snappedMinutes = Math.round(minuteInHour / 15) * 15;
        
        // Position preview using viewport coordinates
        const top = gridRect.top + (hourIndex * hourHeight) + (snappedMinutes / 60 * hourHeight) - scrollTop;
        const originalStart = new Date(draggingEvent.start.dateTime);
        const originalEnd = new Date(draggingEvent.end.dateTime);
        const duration = (originalEnd - originalStart) / (1000 * 60 * 60); // in hours
        const height = duration * hourHeight;
        
        // Use the column's bounding rect for positioning
        const colRect = targetColumn.getBoundingClientRect();
        
        return {
          top,
          height,
          left: colRect.left,
          width: colRect.width
        };
      };

      const findOverlappingEventsInColumn = (event, columnEvents) => {
        const eventStart = new Date(event.start.dateTime);
        const eventEnd = new Date(event.end.dateTime);
        
        return columnEvents.filter(other => {
          if (other.id === event.id) return false;
          const otherStart = new Date(other.start.dateTime);
          const otherEnd = new Date(other.end.dateTime);
          
          // Check if times overlap
          const timesOverlap = eventStart < otherEnd && otherStart < eventEnd;
          if (!timesOverlap) return false;
          
          // Check if they have at least 2 common words
          const words1 = event.summary.toLowerCase().split(/\s+/).filter(w => w.length > 2);
          const words2 = other.summary.toLowerCase().split(/\s+/).filter(w => w.length > 2);
          const commonWords = words1.filter(w => words2.includes(w)).length;
          
          return commonWords >= 2;
        });
      };

      const mergeEvents = async (event1, event2, targetCalendarId) => {
        const eventToHide = event1.calendarId === targetCalendarId ? event2 : event1;
        const eventToKeep = event1.calendarId === targetCalendarId ? event1 : event2;
        
        // Determine which event is longer (the one that will "consume")
        const event1Duration = new Date(event1.end.dateTime) - new Date(event1.start.dateTime);
        const event2Duration = new Date(event2.end.dateTime) - new Date(event2.start.dateTime);
        const longerEvent = event1Duration >= event2Duration ? event1 : event2;
        const shorterEvent = longerEvent.id === event1.id ? event2 : event1;
        
        // Start merge animation
        setMergingEvents({ longer: longerEvent, shorter: shorterEvent });
        
        // Wait for animation
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Hide the shorter event (don't delete from Google Calendar)
        setHiddenEvents(prev => new Set([...prev, shorterEvent.id]));
        localStorage.setItem('hidden_events', JSON.stringify([...hiddenEvents, shorterEvent.id]));
        
        setMergingEvents(null);
      };

      const handleMouseUp = () => {
        if (!isDragging || !dragStart || !dragEnd) return;
        setIsDragging(false);
        
        const start = dragStart.time < dragEnd.time ? dragStart.time : dragEnd.time;
        const end = dragStart.time < dragEnd.time ? dragEnd.time : dragStart.time;
        
        if (end - start < 15 * 60 * 1000) {
          end.setMinutes(start.getMinutes() + 30);
        }

        const column = columns.find(c => c.id === dragStart.columnId);
        const calendarId = column?.calendarIds[0] || defaultCalendar;

        setSelectedEvent({
          start: toLocalDateTimeString(start),
          end: toLocalDateTimeString(end),
          calendarId: calendarId
        });
        setShowEventModal(true);
        setDragStart(null);
        setDragEnd(null);
      };

      const findSimilarEvents = (events) => {
        const groups = [];
        const processed = new Set();

        events.forEach((event, i) => {
          if (processed.has(i)) return;
          
          const similar = [event];
          processed.add(i);

          events.forEach((other, j) => {
            if (i === j || processed.has(j)) return;
            
            const event1Start = new Date(event.start.dateTime || event.start.date);
            const event1End = new Date(event.end.dateTime || event.end.date);
            const event2Start = new Date(other.start.dateTime || other.start.date);
            const event2End = new Date(other.end.dateTime || other.end.date);

            // Check if times overlap
            const timesOverlap = event1Start < event2End && event2Start < event1End;
            
            if (timesOverlap) {
              // Check if they have at least 2 common words
              const words1 = event.summary.toLowerCase().split(/\s+/).filter(w => w.length > 2);
              const words2 = other.summary.toLowerCase().split(/\s+/).filter(w => w.length > 2);
              const commonWords = words1.filter(w => words2.includes(w)).length;
              
              if (commonWords >= 2) {
                similar.push(other);
                processed.add(j);
              }
            }
          });

          if (similar.length > 1) {
            groups.push(similar);
          }
        });

        return groups;
      };

      const calculateSimilarity = (str1, str2) => {
        const s1 = str1.toLowerCase();
        const s2 = str2.toLowerCase();
        const longer = s1.length > s2.length ? s1 : s2;
        const shorter = s1.length > s2.length ? s2 : s1;
        if (longer.length === 0) return 1.0;
        const editDistance = (s1, s2) => {
          const costs = [];
          for (let i = 0; i <= s1.length; i++) {
            let lastValue = i;
            for (let j = 0; j <= s2.length; j++) {
              if (i === 0) {
                costs[j] = j;
              } else if (j > 0) {
                let newValue = costs[j - 1];
                if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                  newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                }
                costs[j - 1] = lastValue;
                lastValue = newValue;
              }
            }
            if (i > 0) costs[s2.length] = lastValue;
          }
          return costs[s2.length];
        };
        return (longer.length - editDistance(longer, shorter)) / longer.length;
      };

      const layoutOverlappingEvents = (events) => {
        if (events.length === 0) return [];
        
        const sorted = [...events].sort((a, b) => {
          const aStart = new Date(a.start.dateTime || a.start.date);
          const bStart = new Date(b.start.dateTime || b.start.date);
          return aStart - bStart;
        });

        // For each event, check what it overlaps with
        const eventLayouts = sorted.map(event => {
          const eventStart = new Date(event.start.dateTime || event.start.date);
          const eventEnd = new Date(event.end.dateTime || event.end.date);
          
          // Find all events this overlaps with
          const overlapping = sorted.filter(other => {
            if (other.id === event.id) return false;
            const otherStart = new Date(other.start.dateTime || other.start.date);
            const otherEnd = new Date(other.end.dateTime || other.end.date);
            return eventStart < otherEnd && otherStart < eventEnd;
          });
          
          return {
            event,
            overlapping: overlapping.length
          };
        });

        // Build columns dynamically
        const columns = [];
        eventLayouts.forEach(({ event, overlapping }) => {
          if (overlapping === 0) {
            // No overlap, gets its own full-width column
            columns.push([event]);
          } else {
            // Has overlap, try to place in existing column
            const eventStart = new Date(event.start.dateTime || event.start.date);
            const eventEnd = new Date(event.end.dateTime || event.end.date);
            
            let placed = false;
            for (let col of columns) {
              const lastEvent = col[col.length - 1];
              const lastEnd = new Date(lastEvent.end.dateTime || lastEvent.end.date);
              if (eventStart >= lastEnd) {
                col.push(event);
                placed = true;
                break;
              }
            }
            if (!placed) {
              columns.push([event]);
            }
          }
        });

        // Assign column info to each event
        return sorted.map(event => {
          const colIndex = columns.findIndex(col => col.includes(event));
          const { overlapping } = eventLayouts.find(el => el.event.id === event.id);
          
          return {
            ...event,
            layoutColumn: colIndex,
            totalColumns: overlapping === 0 ? 1 : columns.length,
            hasOverlap: overlapping > 0
          };
        });
      };

      const renderDayView = () => {
        const hours = Array.from({ length: visibleHourEnd - visibleHourStart + 1 }, (_, i) => i + visibleHourStart);
        const dayEvents = events.filter(event => {
          const eventDate = new Date(event.start.dateTime || event.start.date);
          return eventDate.toDateString() === currentDate.toDateString() && 
                 !hiddenEvents.has(event.id) &&
                 !hiddenCalendars.has(event.calendarId);
        });

        const allDayEvents = dayEvents.filter(event => !event.start.dateTime);
        const timedEvents = dayEvents.filter(event => event.start.dateTime);
        const similarGroups = findSimilarEvents(timedEvents);

        const now = new Date();
        const isToday = currentDate.toDateString() === now.toDateString();
        const currentTimeTop = isToday ? ((now.getHours() - visibleHourStart) * 64) + (now.getMinutes() / 60 * 64) : null;

        return (
          <div className="flex-1 overflow-auto">
            {allDayEvents.length > 0 && (
              <div className="border-b bg-gray-50 p-2">
                <div className="flex gap-2 flex-wrap">
                  {allDayEvents.map(event => (
                    <div
                      key={event.id}
                      className="px-3 py-1 rounded text-sm text-white cursor-pointer"
                      style={{ backgroundColor: event.calendarColor || 'var(--dartmouth-green)' }}
                      onClick={() => {
                        setSelectedEvent(event);
                        setShowEventModal(true);
                      }}
                    >
                      {event.summary}
                    </div>
                  ))}
                </div>
              </div>
            )}

            <div className="flex border-b bg-gray-50" style={{ borderColor: 'var(--border-color)' }}>
              <div className="w-16 flex-shrink-0 border-r" style={{ borderColor: 'var(--border-color)' }}></div>
              {columns.map((column, idx) => (
                <div key={column.id} className="flex-1 p-2 border-r font-semibold text-center flex items-center justify-center gap-2" style={{ borderColor: 'var(--border-color)', backgroundColor: 'white' }}>
                  {column.name}
                  {idx === columns.length - 1 && (
                    <button
                      onClick={addColumn}
                      className="p-1 hover:bg-gray-200 rounded"
                      title="Add Column"
                    >
                      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                      </svg>
                    </button>
                  )}
                </div>
              ))}
            </div>
            
            <div className="flex relative">
              <div className="w-16 flex-shrink-0">
                {hours.map(hour => (
                  <div key={hour} className="h-16 border-b text-xs text-gray-500 p-1">
                    {hour % 12 || 12}{hour >= 12 ? 'PM' : 'AM'}
                  </div>
                ))}
              </div>
              
              {columns.map(column => {
                const columnEvents = timedEvents.filter(event => column.calendarIds.includes(event.calendarId));
                const layoutedEvents = layoutOverlappingEvents(columnEvents);
                
                return (
                  <div key={column.id} data-column-id={column.id} className="calendar-column flex-1 border-r relative">
                    <div className="time-grid">
                      {hours.map(hour => (
                        <div
                          key={hour}
                          data-hour-slot={hour}
                          className="h-16 border-b hover:bg-gray-50 cursor-crosshair relative"
                          onMouseDown={(e) => handleMouseDown(e, hour, column.id)}
                          onMouseMove={(e) => {
                            handleMouseMove(e, hour);
                            handleEventDrag(e, hour);
                          }}
                          onMouseUp={(e) => {
                            handleMouseUp();
                            handleEventDragEnd(e, hour, column.id);
                          }}
                        >
                          {hour !== 23 && <div className="absolute top-1/2 left-0 right-0 border-t border-gray-200"></div>}
                        </div>
                      ))}
                    </div>
                    
                    {layoutedEvents.map(event => {
                      if (hiddenEvents.has(event.id)) return null;
                      
                      const start = new Date(event.start.dateTime);
                      const end = new Date(event.end.dateTime);
                      
                      // Don't apply any offset to displayed events
                      const topHour = Math.max(start.getHours(), visibleHourStart);
                      const bottomHour = Math.min(end.getHours(), visibleHourEnd);
                      
                      // Skip if completely out of range
                      if (bottomHour <= visibleHourStart || topHour >= visibleHourEnd) return null;
                      
                      const top = ((topHour - visibleHourStart) * 64) + (start.getMinutes() / 60 * 64);
                      const height = Math.max(((bottomHour - topHour) * 64) + ((end.getMinutes() - start.getMinutes()) / 60 * 64), 20);
                      
                      const similarGroup = similarGroups.find(group => group.some(e => e.id === event.id));
                      const isInGroup = similarGroup && similarGroup.length > 1;
                      const groupCalendars = isInGroup ? [...new Set(similarGroup.map(e => e.calendarId))] : [event.calendarId];
                      
                      // Check for overlapping similar events in the same column
                      const overlappingInColumn = findOverlappingEventsInColumn(event, columnEvents);
                      const canMerge = overlappingInColumn.length > 0;
                      
                      // Check if this event is being merged
                      const isMergingOut = mergingEvents?.shorter?.id === event.id;
                      
                      let backgroundColor = calendarColors[event.calendarId] || event.calendarColor || 'var(--dartmouth-green)';
                      
                      if (isInGroup && groupCalendars.length > 1) {
                        const colors = groupCalendars.map(id => calendarColors[id] || calendars.find(c => c.id === id)?.backgroundColor || 'var(--dartmouth-green)');
                        backgroundColor = `linear-gradient(90deg, ${colors.join(', ')})`;
                      }
                      
                      return (
                        <div
                          key={event.id}
                          className={`absolute rounded text-xs text-white cursor-move overflow-visible event-block ${
                            draggingEvent?.id === event.id ? 'event-dragging-active' : ''
                          } ${isMergingOut ? 'merging-out' : ''}`}
                          style={{
                            top: draggingEvent?.id === event.id && dragPosition ? 
                              `${dragPosition.y - (dragOffset?.y || 0)}px` : `${top}px`,
                            height: `${height}px`,
                            left: draggingEvent?.id === event.id ? 
                              '4px' : (event.hasOverlap ? `${(event.layoutColumn / event.totalColumns * 100)}%` : '4px'),
                            width: event.hasOverlap ? `calc(${100 / event.totalColumns}% - 4px)` : 'calc(100% - 8px)',
                            background: backgroundColor,
                            border: 'none',
                            zIndex: draggingEvent?.id === event.id ? 1000 : (isMergingOut ? 999 : 1),
                            position: draggingEvent?.id === event.id ? 'fixed' : 'absolute'
                          }}
                          onMouseEnter={() => setHoveredEvent(event.id)}
                          onMouseLeave={() => setHoveredEvent(null)}
                          onMouseDown={(e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            handleEventDragStart(e, event);
                          }}
                          onClick={(e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            if (!draggingEvent && !isMergingOut) {
                              setSelectedEvent(event);
                              setShowEventModal(true);
                            }
                          }}
                        >
                          <div className="p-1.5 pointer-events-none">
                            <div className="font-medium truncate text-sm">{event.summary}</div>
                            <div className="text-xs opacity-80 mt-0.5">
                              {start.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}
                            </div>
                          </div>
                          {canMerge && !isMergingOut && hoveredEvent === event.id && (
                            <div 
                              className="absolute top-1 right-1 bg-white text-gray-800 rounded px-1.5 py-0.5 text-xs cursor-pointer hover:bg-gray-200 shadow-sm"
                              style={{ pointerEvents: 'auto', fontSize: '10px' }}
                              onClick={(e) => {
                                e.stopPropagation();
                                e.preventDefault();
                                const otherEvent = overlappingInColumn[0];
                                setShowMergeDialog({
                                  event1: event,
                                  event2: otherEvent
                                });
                              }}
                            >
                              Merge
                            </div>
                          )}
                        </div>
                      );
                    })}

                    {isDragging && dragStart?.columnId === column.id && dragStart && dragEnd && (
                      <div
                        className="absolute left-1 right-1 rounded bg-blue-400 opacity-50 pointer-events-none"
                        style={{
                          top: `${Math.min(
                            ((dragStart.time.getHours() - 6) * 64) + (dragStart.time.getMinutes() / 60 * 64),
                            ((dragEnd.time.getHours() - 6) * 64) + (dragEnd.time.getMinutes() / 60 * 64)
                          )}px`,
                          height: `${Math.abs(
                            (((dragEnd.time.getHours() - 6) * 64) + (dragEnd.time.getMinutes() / 60 * 64)) -
                            (((dragStart.time.getHours() - 6) * 64) + (dragStart.time.getMinutes() / 60 * 64))
                          )}px`
                        }}
                      />
                    )}

                    {isToday && currentTimeTop !== null && currentTimeTop >= 0 && currentTimeTop <= (visibleHourEnd - visibleHourStart + 1) * 64 && (
                      <div className="current-time-indicator" style={{ top: `${currentTimeTop}px` }} />
                    )}
                  </div>
                );
              })}
            </div>
            
            {/* Drag preview indicator */}
            {draggingEvent && dragPosition && (() => {
              const previewPos = getDropPreviewPosition();
              if (!previewPos) return null;
              
              const eventColor = calendarColors[draggingEvent.calendarId] || draggingEvent.calendarColor || 'var(--dartmouth-green)';
              
              return (
                <div
                  className="fixed rounded pointer-events-none"
                  style={{
                    top: `${previewPos.top}px`,
                    left: `${previewPos.left}px`,
                    width: `${previewPos.width - 8}px`,
                    height: `${previewPos.height}px`,
                    backgroundColor: eventColor,
                    opacity: 0.3,
                    border: `2px dashed ${eventColor}`,
                    zIndex: 999
                  }}
                />
              );
            })()}
          </div>
        );
      };

      const renderWeekView = () => {
        const startOfWeek = new Date(currentDate);
        startOfWeek.setDate(currentDate.getDate() - currentDate.getDay());
        const days = Array.from({ length: 7 }, (_, i) => {
          const day = new Date(startOfWeek);
          day.setDate(startOfWeek.getDate() + i);
          return day;
        });

        const hours = Array.from({ length: 18 }, (_, i) => i + 6);
        const now = new Date();
        
        // Filter events based on showOnlyColumn1 setting
        const filteredEvents = showOnlyColumn1 && columns.length > 0
          ? events.filter(event => columns[0].calendarIds.includes(event.calendarId))
          : events;

        return (
          <div className="flex-1 overflow-auto">
            <div className="flex border-b bg-gray-50">
              <div className="w-16 flex-shrink-0 border-r"></div>
              {days.map(day => (
                <div key={day.toISOString()} className="flex-1 p-2 border-r text-center">
                  <div className="font-semibold">{day.toLocaleDateString('en-US', { weekday: 'short' })}</div>
                  <div className="text-sm text-gray-600">{day.getDate()}</div>
                </div>
              ))}
            </div>

            <div className="flex">
              <div className="w-16 flex-shrink-0">
                {hours.map(hour => (
                  <div key={hour} className="h-16 border-b text-xs text-gray-500 p-1">
                    {hour % 12 || 12}{hour >= 12 ? 'PM' : 'AM'}
                  </div>
                ))}
              </div>

              {days.map(day => {
                const dayEvents = filteredEvents.filter(event => {
                  const eventDate = new Date(event.start.dateTime || event.start.date);
                  return eventDate.toDateString() === day.toDateString() && event.start.dateTime;
                });

                const layoutedEvents = layoutOverlappingEvents(dayEvents);
                const isToday = day.toDateString() === now.toDateString();
                const currentTimeTop = isToday ? ((now.getHours() - 6) * 64) + (now.getMinutes() / 60 * 64) : null;

                return (
                  <div key={day.toISOString()} className="flex-1 border-r relative">
                    {hours.map(hour => (
                      <div key={hour} className="h-16 border-b hover:bg-gray-50 relative">
                        {hour !== 23 && <div className="absolute top-1/2 left-0 right-0 border-t border-gray-200"></div>}
                      </div>
                    ))}

                    {layoutedEvents.map(event => {
                      const start = new Date(event.start.dateTime);
                      const end = new Date(event.end.dateTime);
                      const top = ((start.getHours() - 6) * 64) + (start.getMinutes() / 60 * 64);
                      const height = ((end - start) / (1000 * 60 * 60)) * 64;

                      return (
                        <div
                          key={event.id}
                          className="absolute rounded text-xs text-white cursor-pointer overflow-hidden"
                          style={{
                            top: `${top}px`,
                            height: `${height}px`,
                            left: event.totalColumns === 1 ? '2px' : `${(event.layoutColumn / event.totalColumns * 100)}%`,
                            width: event.totalColumns === 1 ? 'calc(100% - 4px)' : `calc(${100 / event.totalColumns}% - 2px)`,
                            backgroundColor: event.calendarColor || 'var(--dartmouth-green)',
                            border: event.totalColumns > 1 ? '1px solid white' : 'none',
                            marginLeft: '0',
                            marginRight: '0'
                          }}
                          onClick={() => {
                            setSelectedEvent(event);
                            setShowEventModal(true);
                          }}
                        >
                          <div className="p-1">
                            <div className="font-semibold truncate">{event.summary}</div>
                          </div>
                        </div>
                      );
                    })}

                    {isToday && currentTimeTop !== null && currentTimeTop >= 0 && currentTimeTop <= 18 * 64 && (
                      <div className="current-time-indicator" style={{ top: `${currentTimeTop}px` }} />
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        );
      };

      const renderMonthView = () => {
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();
        const firstDay = new Date(year, month, 1);
        const startDate = new Date(firstDay);
        startDate.setDate(startDate.getDate() - startDate.getDay());
        
        const days = [];
        const current = new Date(startDate);
        while (days.length < 42) {
          days.push(new Date(current));
          current.setDate(current.getDate() + 1);
        }

        // Filter events based on showOnlyColumn1 setting
        const filteredEvents = showOnlyColumn1 && columns.length > 0
          ? events.filter(event => columns[0].calendarIds.includes(event.calendarId))
          : events;

        return (
          <div className="flex-1 overflow-auto p-4">
            <div className="grid grid-cols-7 gap-px bg-gray-200">
              {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => (
                <div key={day} className="bg-gray-50 p-2 text-center font-semibold text-sm" style={{ color: 'var(--dartmouth-green)' }}>
                  {day}
                </div>
              ))}
              {days.map(day => (
                <div
                  key={day.toISOString()}
                  className={`bg-white p-2 min-h-[100px] ${
                    day.getMonth() !== month ? 'text-gray-400' : ''
                  }`}
                >
                  <div className="font-semibold mb-1">{day.getDate()}</div>
                  {filteredEvents
                    .filter(event => {
                      const eventDate = new Date(event.start.dateTime || event.start.date);
                      return eventDate.toDateString() === day.toDateString();
                    })
                    .slice(0, 3)
                    .map(event => (
                      <div
                        key={event.id}
                        className="mb-1 p-1 rounded text-xs text-white cursor-pointer truncate"
                        style={{ backgroundColor: event.calendarColor || 'var(--dartmouth-green)' }}
                        onClick={() => {
                          setSelectedEvent(event);
                          setShowEventModal(true);
                        }}
                      >
                        {event.summary}
                      </div>
                    ))}
                </div>
              ))}
            </div>
          </div>
        );
      };

      const renderMiniCalendar = () => {
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();
        const firstDay = new Date(year, month, 1);
        const startDate = new Date(firstDay);
        startDate.setDate(startDate.getDate() - startDate.getDay());
        
        const days = [];
        const current = new Date(startDate);
        while (days.length < 42) {
          days.push(new Date(current));
          current.setDate(current.getDate() + 1);
        }
        
        const today = new Date();

        return (
          <div className="w-64 border-r p-4 overflow-auto" style={{ borderColor: 'var(--border-color)', backgroundColor: 'white' }}>
            <div className="mb-4">
              <div className="flex items-center justify-between mb-3">
                <h3 className="font-semibold">{currentDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}</h3>
                <div className="flex gap-1">
                  <button
                    onClick={() => {
                      const newDate = new Date(currentDate);
                      newDate.setMonth(newDate.getMonth() - 1);
                      setCurrentDate(newDate);
                    }}
                    className="p-1 hover:bg-gray-100 rounded"
                  >
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                    </svg>
                  </button>
                  <button
                    onClick={() => {
                      const newDate = new Date(currentDate);
                      newDate.setMonth(newDate.getMonth() + 1);
                      setCurrentDate(newDate);
                    }}
                    className="p-1 hover:bg-gray-100 rounded"
                  >
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                    </svg>
                  </button>
                </div>
              </div>
              
              <div className="grid grid-cols-7 gap-1 text-xs">
                {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day, i) => (
                  <div key={i} className="text-center text-gray-500 font-medium py-1">
                    {day}
                  </div>
                ))}
                {days.map(day => {
                  const isCurrentMonth = day.getMonth() === month;
                  const isToday = day.toDateString() === today.toDateString();
                  const isSelected = day.toDateString() === currentDate.toDateString();
                  
                  return (
                    <button
                      key={day.toISOString()}
                      onClick={() => setCurrentDate(new Date(day))}
                      className={`text-center py-1 rounded text-sm ${
                        !isCurrentMonth ? 'text-gray-300' :
                        isToday ? 'bg-blue-500 text-white font-semibold' :
                        isSelected ? 'bg-gray-200 font-medium' :
                        'hover:bg-gray-100'
                      }`}
                    >
                      {day.getDate()}
                    </button>
                  );
                })}
              </div>
            </div>
            
            <div className="border-t pt-4" style={{ borderColor: 'var(--border-color)' }}>
              <h3 className="font-semibold mb-3 text-sm">My Calendars</h3>
              <div className="space-y-2">
                {calendars.map(cal => (
                  <div key={cal.id} className="flex items-center gap-2 hover:bg-gray-50 p-1.5 rounded relative">
                    <div
                      className="w-3 h-3 rounded cursor-pointer hover:ring-2 hover:ring-offset-1 hover:ring-gray-400 flex-shrink-0"
                      style={{ backgroundColor: calendarColors[cal.id] || cal.backgroundColor }}
                      title="Change calendar color"
                      onClick={(e) => {
                        e.stopPropagation();
                        setEditingCalendarColor(editingCalendarColor === cal.id ? null : cal.id);
                      }}
                    />
                    <span className="text-sm flex-1 truncate">{cal.summary}</span>
                    <button
                      onClick={() => {
                        const newHidden = new Set(hiddenCalendars);
                        if (newHidden.has(cal.id)) {
                          newHidden.delete(cal.id);
                        } else {
                          newHidden.add(cal.id);
                        }
                        setHiddenCalendars(newHidden);
                        localStorage.setItem('hidden_calendars', JSON.stringify([...newHidden]));
                      }}
                      className={`flex-shrink-0 ${hiddenCalendars.has(cal.id) ? 'text-gray-300' : 'text-gray-600'} hover:text-gray-800`}
                      title={hiddenCalendars.has(cal.id) ? 'Show calendar' : 'Hide calendar'}
                    >
                      {hiddenCalendars.has(cal.id) ? (
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                        </svg>
                      ) : (
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                      )}
                    </button>
                  </div>
                ))}
                
                {editingCalendarColor && (
                  <div className="fixed left-72 bg-white border rounded shadow-xl p-4 z-50" style={{ top: '50%', transform: 'translateY(-50%)' }}>
                    <h4 className="font-semibold mb-3 text-sm">Choose Color</h4>
                    <div className="mb-3">
                      <input
                        type="color"
                        value={calendarColors[editingCalendarColor] || calendars.find(c => c.id === editingCalendarColor)?.backgroundColor || '#3F51B5'}
                        onChange={(e) => {
                          const newColors = { ...calendarColors, [editingCalendarColor]: e.target.value };
                          setCalendarColors(newColors);
                          localStorage.setItem('calendar_colors', JSON.stringify(newColors));
                        }}
                        className="w-full h-10 cursor-pointer"
                      />
                    </div>
                    <div className="grid grid-cols-6 gap-2 mb-3">
                      {['#D32F2F', '#E67C73', '#F4511E', '#F6BF26', '#33B679', '#0B8043', 
                        '#039BE5', '#3F51B5', '#7986CB', '#8E24AA', '#616161', '#A79B8E'].map(color => (
                        <button
                          key={color}
                          className="w-8 h-8 rounded hover:ring-2 hover:ring-offset-1 hover:ring-gray-400"
                          style={{ backgroundColor: color }}
                          onClick={() => {
                            const newColors = { ...calendarColors, [editingCalendarColor]: color };
                            setCalendarColors(newColors);
                            localStorage.setItem('calendar_colors', JSON.stringify(newColors));
                          }}
                        />
                      ))}
                    </div>
                    <button
                      onClick={() => setEditingCalendarColor(null)}
                      className="w-full text-sm px-3 py-1.5 bg-gray-100 rounded hover:bg-gray-200"
                    >
                      Done
                    </button>
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      };

      if (!isSignedIn) {
        return (
          <div className="h-screen flex items-center justify-center" style={{ backgroundColor: 'var(--light-green)' }}>
            <div className="bg-white rounded-lg shadow-lg p-8 text-center">
              <svg className="w-16 h-16 mx-auto mb-4" viewBox="0 0 64 64" fill="var(--dartmouth-green)">
                <path d="M32 8 C20 8, 12 16, 12 28 C12 36, 16 42, 22 46 L20 56 L32 50 L44 56 L42 46 C48 42, 52 36, 52 28 C52 16, 44 8, 32 8 M32 12 C42 12, 48 18, 48 28 C48 34, 45 39, 40 42 L38 44 L39 50 L32 46 L25 50 L26 44 L24 42 C19 39, 16 34, 16 28 C16 18, 22 12, 32 12" />
                <ellipse cx="26" cy="26" rx="3" ry="4" />
                <ellipse cx="38" cy="26" rx="3" ry="4" />
                <path d="M24 32 Q32 36 40 32" stroke="var(--dartmouth-green)" strokeWidth="2" fill="none" />
              </svg>
              <h1 className="text-2xl font-bold mb-4" style={{ color: 'var(--dartmouth-green)' }}>Remora Calendar</h1>
              
              {isLoading && (
                <div className="mb-4">
                  <div className="animate-spin rounded-full h-8 w-8 border-b-2 mx-auto mb-2" style={{ borderColor: 'var(--dartmouth-green)' }}></div>
                  <p className="text-sm text-gray-600">{loadingMessage}</p>
                </div>
              )}
              
              {error && (
                <div className="mb-4 p-3 bg-red-50 text-red-600 rounded text-sm">
                  {error}
                </div>
              )}
              
              <button
                onClick={signIn}
                disabled={isLoading}
                className="text-white rounded px-6 py-3 hover:opacity-90 disabled:opacity-50"
                style={{ backgroundColor: 'var(--dartmouth-green)' }}
              >
                {isLoading ? 'Loading...' : 'Sign in with Google'}
              </button>
            </div>
          </div>
        );
      }

      return (
        <div className="h-screen flex flex-col" style={{ backgroundColor: 'var(--bg-color)' }}>
          {loadingMessage && (
            <div className="bg-blue-50 border-b px-4 py-2 text-sm text-blue-800 flex items-center gap-2" style={{ borderColor: 'var(--border-color)' }}>
              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-800"></div>
              {loadingMessage}
            </div>
          )}
          
          {error && (
            <div className="bg-red-50 border-b px-4 py-2 text-sm text-red-800 flex items-center justify-between" style={{ borderColor: 'var(--border-color)' }}>
              <span>{error}</span>
              <button onClick={() => setError(null)} className="text-red-600 hover:text-red-800"></button>
            </div>
          )}
          
          <div className="border-b p-3 flex items-center justify-between bg-white" style={{ borderColor: 'var(--border-color)' }}>
            <div className="flex items-center gap-4">
              <svg className="w-6 h-6" viewBox="0 0 64 64" fill="var(--dartmouth-green)">
                <path d="M32 8 C20 8, 12 16, 12 28 C12 36, 16 42, 22 46 L20 56 L32 50 L44 56 L42 46 C48 42, 52 36, 52 28 C52 16, 44 8, 32 8 M32 12 C42 12, 48 18, 48 28 C48 34, 45 39, 40 42 L38 44 L39 50 L32 46 L25 50 L26 44 L24 42 C19 39, 16 34, 16 28 C16 18, 22 12, 32 12" />
                <ellipse cx="26" cy="26" rx="3" ry="4" />
                <ellipse cx="38" cy="26" rx="3" ry="4" />
                <path d="M24 32 Q32 36 40 32" stroke="var(--dartmouth-green)" strokeWidth="2" fill="none" />
              </svg>
              <h1 className="text-xl font-bold" style={{ color: 'var(--dartmouth-green)' }}>Remora</h1>
              
              <div className="flex items-center gap-2 ml-8">
                <button
                  onClick={() => {
                    const newDate = new Date(currentDate);
                    if (view === 'day') newDate.setDate(newDate.getDate() - 1);
                    else if (view === 'week') newDate.setDate(newDate.getDate() - 7);
                    else newDate.setMonth(newDate.getMonth() - 1);
                    setCurrentDate(newDate);
                  }}
                  className="p-1 hover:bg-gray-100 rounded"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                  </svg>
                </button>
                
                <button
                  onClick={() => setCurrentDate(new Date())}
                  className="px-3 py-1 rounded"
                  style={{ backgroundColor: 'var(--light-green)', color: 'var(--dartmouth-green)' }}
                >
                  Today
                </button>
                
                <button
                  onClick={() => {
                    const newDate = new Date(currentDate);
                    if (view === 'day') newDate.setDate(newDate.getDate() + 1);
                    else if (view === 'week') newDate.setDate(newDate.getDate() + 7);
                    else newDate.setMonth(newDate.getMonth() + 1);
                    setCurrentDate(newDate);
                  }}
                  className="p-1 hover:bg-gray-100 rounded"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                  </svg>
                </button>
                
                <span className="ml-4 font-semibold">
                  {currentDate.toLocaleDateString('en-US', { 
                    month: 'long', 
                    day: view === 'day' ? 'numeric' : undefined,
                    year: 'numeric' 
                  })}
                </span>
              </div>
            </div>
            
            <div className="flex items-center gap-2">
              <div className="flex border rounded overflow-hidden" style={{ borderColor: 'var(--dartmouth-green)' }}>
                <button
                  onClick={() => setView('day')}
                  className={`px-4 py-2 ${view === 'day' ? 'text-white' : 'hover:bg-gray-100'}`}
                  style={view === 'day' ? { backgroundColor: 'var(--dartmouth-green)' } : {}}
                >
                  Day
                </button>
                <button
                  onClick={() => setView('week')}
                  className={`px-4 py-2 ${view === 'week' ? 'text-white' : 'hover:bg-gray-100'}`}
                  style={view === 'week' ? { backgroundColor: 'var(--dartmouth-green)' } : {}}
                >
                  Week
                </button>
                <button
                  onClick={() => setView('month')}
                  className={`px-4 py-2 ${view === 'month' ? 'text-white' : 'hover:bg-gray-100'}`}
                  style={view === 'month' ? { backgroundColor: 'var(--dartmouth-green)' } : {}}
                >
                  Month
                </button>
              </div>
              
              <button
                onClick={() => setShowSettings(true)}
                className="p-2 hover:bg-gray-100 rounded"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
              </button>
              
              <button
                onClick={signOut}
                className="ml-2 px-4 py-2 text-sm text-gray-600 hover:bg-gray-100 rounded"
              >
                Sign Out
              </button>
            </div>
          </div>

          <div className="flex flex-1 overflow-hidden">
            {renderMiniCalendar()}
            
            <div className="flex-1 flex flex-col p-4">
              {view === 'day' && renderDayView()}
              {view === 'week' && renderWeekView()}
              {view === 'month' && renderMonthView()}
            </div>
          </div>

          {showSettings && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
              <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] overflow-auto">
                <div className="p-6">
                  <div className="flex justify-between items-center mb-6">
                    <h2 className="text-xl font-bold" style={{ color: 'var(--dartmouth-green)' }}>Settings</h2>
                    <button onClick={() => setShowSettings(false)} className="p-1 hover:bg-gray-100 rounded">
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>
                  
                  <div className="space-y-6">
                    <div>
                      <label className="block font-semibold mb-2">Event Creation Time Calibration</label>
                      <div className="flex items-center gap-2">
                        <span className="text-sm">Offset (hours):</span>
                        <input
                          type="number"
                          value={timeZoneOffset}
                          onChange={(e) => {
                            const offset = parseFloat(e.target.value) || 0;
                            setTimeZoneOffset(offset);
                            localStorage.setItem('timezone_offset', offset.toString());
                          }}
                          className="w-24 border rounded px-3 py-2"
                          step="0.5"
                        />
                        <span className="text-xs text-gray-500">Adjust if event creation times are incorrect (can be negative)</span>
                      </div>
                    </div>
                    
                    <div>
                      <label className="block font-semibold mb-2">Visible Time Range</label>
                      <div className="flex items-center gap-4">
                        <div>
                          <span className="text-sm">Start:</span>
                          <select
                            value={visibleHourStart}
                            onChange={(e) => {
                              const start = parseInt(e.target.value);
                              setVisibleHourStart(start);
                              localStorage.setItem('visible_hour_start', start.toString());
                            }}
                            className="ml-2 border rounded px-2 py-1"
                          >
                            {Array.from({ length: 24 }, (_, i) => (
                              <option key={i} value={i}>{i % 12 || 12} {i >= 12 ? 'PM' : 'AM'}</option>
                            ))}
                          </select>
                        </div>
                        <div>
                          <span className="text-sm">End:</span>
                          <select
                            value={visibleHourEnd}
                            onChange={(e) => {
                              const end = parseInt(e.target.value);
                              setVisibleHourEnd(end);
                              localStorage.setItem('visible_hour_end', end.toString());
                            }}
                            className="ml-2 border rounded px-2 py-1"
                          >
                            {Array.from({ length: 24 }, (_, i) => (
                              <option key={i} value={i}>{i % 12 || 12} {i >= 12 ? 'PM' : 'AM'}</option>
                            ))}
                          </select>
                        </div>
                      </div>
                    </div>
                    
                    <div>
                      <label className="block font-semibold mb-2">Default Calendar</label>
                      <select
                        value={defaultCalendar}
                        onChange={(e) => {
                          setDefaultCalendar(e.target.value);
                          localStorage.setItem('default_calendar', e.target.value);
                        }}
                        className="w-full border rounded px-3 py-2"
                      >
                        {calendars.map(cal => (
                          <option key={cal.id} value={cal.id}>{cal.summary}</option>
                        ))}
                      </select>
                    </div>
                    
                    <div>
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={showOnlyColumn1}
                          onChange={(e) => {
                            setShowOnlyColumn1(e.target.checked);
                            localStorage.setItem('show_only_column1', e.target.checked.toString());
                          }}
                          className="rounded"
                        />
                        <span className="text-sm font-semibold">Week/Month View: Show only Column 1 calendars</span>
                      </label>
                    </div>
                    
                    <div>
                      <h3 className="font-semibold mb-3">Column Configuration</h3>
                      {columns.map(column => (
                        <div key={column.id} className="mb-4 p-4 border rounded">
                          <div className="flex justify-between items-center mb-2">
                            <input
                              type="text"
                              value={column.name}
                              onChange={(e) => {
                                const updated = columns.map(col =>
                                  col.id === column.id ? { ...col, name: e.target.value } : col
                                );
                                setColumns(updated);
                                localStorage.setItem('calendar_columns', JSON.stringify(updated));
                              }}
                              className="font-semibold border rounded px-2 py-1"
                            />
                            {columns.length > 1 && (
                              <button
                                onClick={() => removeColumn(column.id)}
                                className="text-red-600 hover:bg-red-50 p-1 rounded"
                              >
                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                </svg>
                              </button>
                            )}
                          </div>
                          
                          <div className="space-y-1">
                            {calendars.map(cal => (
                              <label key={cal.id} className="flex items-center gap-2 p-2 hover:bg-gray-50 rounded cursor-pointer">
                                <input
                                  type="checkbox"
                                  checked={column.calendarIds.includes(cal.id)}
                                  onChange={(e) => {
                                    if (e.target.checked) {
                                      moveCalendarToColumn(cal.id, column.id);
                                    } else {
                                      const updated = columns.map(col => ({
                                        ...col,
                                        calendarIds: col.calendarIds.filter(id => id !== cal.id)
                                      }));
                                      setColumns(updated);
                                      localStorage.setItem('calendar_columns', JSON.stringify(updated));
                                    }
                                  }}
                                  className="rounded"
                                />
                                <div
                                  className="w-3 h-3 rounded"
                                  style={{ backgroundColor: cal.backgroundColor }}
                                />
                                <span className="text-sm">{cal.summary}</span>
                              </label>
                            ))}
                          </div>
                        </div>
                      ))}
                    </div>

                    <div className="text-sm text-gray-600 p-3 rounded" style={{ backgroundColor: 'var(--light-green)' }}>
                      <strong>Keyboard Shortcuts:</strong>
                      <div className="mt-2 space-y-1">
                        <div><kbd className="px-2 py-1 bg-white rounded border">D</kbd> - Day view</div>
                        <div><kbd className="px-2 py-1 bg-white rounded border">W</kbd> - Week view</div>
                        <div><kbd className="px-2 py-1 bg-white rounded border">M</kbd> - Month view</div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {showMergeDialog && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-[2000]">
              <div className="bg-white rounded-lg shadow-xl max-w-md w-full p-6">
                <h3 className="text-lg font-bold mb-4">Merge Events</h3>
                <p className="text-sm text-gray-600 mb-4">
                  Select which calendar to keep the merged event in:
                </p>
                <div className="space-y-2 mb-6">
                  <button
                    onClick={() => {
                      mergeEvents(showMergeDialog.event1, showMergeDialog.event2, showMergeDialog.event1.calendarId);
                      setShowMergeDialog(null);
                    }}
                    className="w-full p-3 border-2 rounded hover:bg-gray-50 text-left"
                    style={{ borderColor: showMergeDialog.event1.calendarColor }}
                  >
                    <div className="flex items-center gap-2">
                      <div className="w-4 h-4 rounded" style={{ backgroundColor: showMergeDialog.event1.calendarColor }} />
                      <span className="font-medium">
                        {calendars.find(c => c.id === showMergeDialog.event1.calendarId)?.summary}
                      </span>
                    </div>
                  </button>
                  <button
                    onClick={() => {
                      mergeEvents(showMergeDialog.event1, showMergeDialog.event2, showMergeDialog.event2.calendarId);
                      setShowMergeDialog(null);
                    }}
                    className="w-full p-3 border-2 rounded hover:bg-gray-50 text-left"
                    style={{ borderColor: showMergeDialog.event2.calendarColor }}
                  >
                    <div className="flex items-center gap-2">
                      <div className="w-4 h-4 rounded" style={{ backgroundColor: showMergeDialog.event2.calendarColor }} />
                      <span className="font-medium">
                        {calendars.find(c => c.id === showMergeDialog.event2.calendarId)?.summary}
                      </span>
                    </div>
                  </button>
                </div>
                <button
                  onClick={() => setShowMergeDialog(null)}
                  className="w-full px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
                >
                  Cancel
                </button>
              </div>
            </div>
          )}

          {showEventModal && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
              <div className="bg-white rounded-lg shadow-xl max-w-md w-full">
                <div className="p-6">
                  <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl font-bold" style={{ color: 'var(--dartmouth-green)' }}>
                      {selectedEvent?.id ? 'Edit Event' : 'New Event'}
                    </h2>
                    <button onClick={() => { setShowEventModal(false); setSelectedEvent(null); }} className="p-1 hover:bg-gray-100 rounded">
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>
                  
                  <EventForm
                    event={selectedEvent}
                    calendars={calendars}
                    defaultCalendar={defaultCalendar}
                    onSave={(data) => {
                      if (selectedEvent?.id) {
                        updateEvent({ ...selectedEvent, ...data });
                      } else {
                        createEvent(data);
                      }
                    }}
                    onDelete={selectedEvent?.id ? () => deleteEvent(selectedEvent) : null}
                  />
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    const EventForm = ({ event, calendars, defaultCalendar, onSave, onDelete }) => {
      const [title, setTitle] = React.useState(event?.summary || '');
      const [description, setDescription] = React.useState(event?.description || '');
      const getStartTime = () => {
        if (event?.start?.dateTime) return event.start.dateTime.slice(0, 16);
        if (event?.start) return new Date(event.start).toISOString().slice(0, 16);
        return '';
      };
      
      const getEndTime = () => {
        if (event?.end?.dateTime) return event.end.dateTime.slice(0, 16);
        if (event?.end) return new Date(event.end).toISOString().slice(0, 16);
        return '';
      };

      const [start, setStart] = React.useState(getStartTime());
      const [end, setEnd] = React.useState(getEndTime());
      const [calendarId, setCalendarId] = React.useState(event?.calendarId || defaultCalendar || calendars[0]?.id || '');

      return (
        <form onSubmit={(e) => {
          e.preventDefault();
          onSave({ 
            title, 
            description, 
            start: new Date(start).toISOString(), 
            end: new Date(end).toISOString(), 
            calendarId 
          });
        }} className="space-y-4">
          <div>
            <input
              type="text"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              className="w-full border-b-2 px-0 py-2 text-xl focus:outline-none"
              placeholder="Add title"
              style={{ borderColor: 'var(--dartmouth-green)' }}
              required
            />
          </div>
          
          <div className="flex gap-4">
            <div className="flex-1">
              <label className="block text-sm font-medium mb-1">Start</label>
              <input
                type="datetime-local"
                value={start}
                onChange={(e) => setStart(e.target.value)}
                className="w-full border rounded px-3 py-2"
                required
              />
            </div>
            
            <div className="flex-1">
              <label className="block text-sm font-medium mb-1">End</label>
              <input
                type="datetime-local"
                value={end}
                onChange={(e) => setEnd(e.target.value)}
                className="w-full border rounded px-3 py-2"
                required
              />
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium mb-1">Calendar</label>
            <select
              value={calendarId}
              onChange={(e) => setCalendarId(e.target.value)}
              className="w-full border rounded px-3 py-2"
            >
              {calendars.map(cal => (
                <option key={cal.id} value={cal.id}>{cal.summary}</option>
              ))}
            </select>
          </div>
          
          <div>
            <label className="block text-sm font-medium mb-1">Description</label>
            <textarea
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full border rounded px-3 py-2"
              rows={3}
              placeholder="Add description"
            />
          </div>
          
          <div className="flex gap-2 justify-end pt-4">
            {onDelete && (
              <button
                type="button"
                onClick={onDelete}
                className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
              >
                Delete
              </button>
            )}
            <button
              type="submit"
              className="px-6 py-2 text-white rounded hover:opacity-90"
              style={{ backgroundColor: 'var(--dartmouth-green)' }}
            >
              Save
            </button>
          </div>
        </form>
      );
    };

    ReactDOM.render(<CalendarApp />, document.getElementById('root'));
  </script>
</body>
</html>
